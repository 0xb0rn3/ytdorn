#!/usr/bin/env python3
"""
YtDorn v0.1.2 - Super Powerful YouTube Downloader
Created by: 0xb0rn3
Advanced CLI tool for comprehensive YouTube content downloading with modern UI
"""

import sys
import platform
import subprocess
import os
import json
import asyncio
import concurrent.futures
from typing import Dict, Any, Optional, List, Tuple
import shutil
from datetime import datetime
import time
import threading
from pathlib import Path
import signal
import re
import argparse
from urllib.parse import urlparse, parse_qs
import logging

class Colors:
    """Enhanced color management with modern terminal styling"""
    # Core colors
    PRIMARY = '\033[38;2;64;224;255m'     # Bright cyan
    SECONDARY = '\033[38;2;255;100;255m'   # Bright magenta
    SUCCESS = '\033[38;2;0;255;127m'       # Bright green
    WARNING = '\033[38;2;255;191;0m'       # Bright yellow
    ERROR = '\033[38;2;255;69;58m'         # Bright red
    INFO = '\033[38;2;175;175;255m'        # Light blue
    MUTED = '\033[38;2;128;128;128m'       # Gray
    
    # Text styles
    BOLD = '\033[1m'
    DIM = '\033[2m'
    ITALIC = '\033[3m'
    UNDERLINE = '\033[4m'
    RESET = '\033[0m'
    
    # Special effects
    GLOW = '\033[5m'
    REVERSE = '\033[7m'

    @staticmethod
    def rgb(r: int, g: int, b: int) -> str:
        return f'\033[38;2;{r};{g};{b}m'

    @staticmethod
    def gradient_text(text: str, color1: Tuple[int, int, int], color2: Tuple[int, int, int]) -> str:
        """Create smooth color gradient across text"""
        if not text.strip():
            return text
        
        result = ""
        text_length = len([c for c in text if c.strip()])
        char_index = 0
        
        for char in text:
            if char.strip():
                progress = char_index / max(text_length - 1, 1)
                r = int(color1[0] + (color2[0] - color1[0]) * progress)
                g = int(color1[1] + (color2[1] - color1[1]) * progress)
                b = int(color1[2] + (color2[2] - color1[2]) * progress)
                result += Colors.rgb(r, g, b) + char
                char_index += 1
            else:
                result += char
        return result + Colors.RESET

class ModernSpinner:
    """Advanced spinner with multiple animation styles"""
    
    STYLES = {
        'dots': ['‚†ã', '‚†ô', '‚†π', '‚†∏', '‚†º', '‚†¥', '‚†¶', '‚†ß', '‚†á', '‚†è'],
        'pulse': ['‚óè', '‚óã', '‚óç', '‚óå'],
        'wave': ['‚ñÅ', '‚ñÉ', '‚ñÑ', '‚ñÖ', '‚ñÜ', '‚ñá', '‚ñà', '‚ñá', '‚ñÜ', '‚ñÖ', '‚ñÑ', '‚ñÉ'],
        'arrow': ['‚Üê', '‚Üñ', '‚Üë', '‚Üó', '‚Üí', '‚Üò', '‚Üì', '‚Üô'],
    }
    
    def __init__(self, style='dots'):
        self.frames = self.STYLES.get(style, self.STYLES['dots'])
        self.stop_event = threading.Event()
        self.thread = None
        self.message = ""

    def animate(self):
        """Run the spinner animation"""
        frame_index = 0
        while not self.stop_event.is_set():
            frame = self.frames[frame_index % len(self.frames)]
            sys.stdout.write(f'\r{Colors.PRIMARY}{frame}{Colors.RESET} {self.message}')
            sys.stdout.flush()
            time.sleep(0.1)
            frame_index += 1

    def start(self, message: str):
        """Start spinner with message"""
        self.message = message
        self.stop_event.clear()
        self.thread = threading.Thread(target=self.animate, daemon=True)
        self.thread.start()

    def stop(self, final_message: str = None):
        """Stop spinner and optionally show final message"""
        self.stop_event.set()
        if self.thread:
            self.thread.join()
        sys.stdout.write('\r\033[K')
        if final_message:
            print(final_message)

class AdvancedProgressBar:
    """Modern progress bar with detailed statistics"""
    
    def __init__(self, total: int, description: str = "", width: int = 40):
        self.total = total
        self.description = description
        self.width = width
        self.start_time = time.time()
        self.current = 0
        self.speed_samples = []
        self.last_update = time.time()

    def update(self, current: int, extra_info: str = "") -> str:
        """Update progress with enhanced statistics"""
        self.current = current
        now = time.time()
        
        # Calculate speed with smoothing
        if now - self.last_update > 0.5:  # Update speed every 0.5 seconds
            if self.speed_samples:
                speed = (current - self.speed_samples[-1][1]) / (now - self.speed_samples[-1][0])
            else:
                speed = current / (now - self.start_time) if now > self.start_time else 0
            
            self.speed_samples.append((now, current))
            if len(self.speed_samples) > 10:  # Keep last 10 samples
                self.speed_samples.pop(0)
            self.last_update = now

        # Calculate percentage and bar
        percentage = (current / self.total * 100) if self.total > 0 else 0
        filled = int(self.width * current / self.total) if self.total > 0 else 0
        
        # Create modern progress bar with gradient
        bar_chars = '‚ñà‚ñâ‚ñä‚ñã‚ñå‚ñç‚ñé‚ñè'
        bar = ''
        for i in range(filled):
            intensity = min(255, 50 + (i * 205 // self.width))
            bar += Colors.rgb(intensity, 100, 255) + '‚ñà'
        
        if filled < self.width:
            bar += Colors.MUTED + '‚ñë' * (self.width - filled)
        bar += Colors.RESET

        # Calculate ETA
        elapsed = now - self.start_time
        if current > 0 and elapsed > 0:
            rate = current / elapsed
            eta_seconds = (self.total - current) / rate if rate > 0 else 0
            eta = self._format_duration(eta_seconds)
        else:
            eta = "--:--"

        # Format sizes
        current_size = self._format_bytes(current)
        total_size = self._format_bytes(self.total)
        
        # Get current speed
        current_speed = ""
        if self.speed_samples:
            recent_speed = (current - self.speed_samples[0][1]) / max(now - self.speed_samples[0][0], 1)
            current_speed = f" @ {self._format_bytes(recent_speed)}/s"

        return (f"\r{Colors.PRIMARY}‚ñ∂{Colors.RESET} {self.description[:30]:<30} "
                f"[{bar}] {percentage:5.1f}% "
                f"({current_size}/{total_size}){current_speed} "
                f"ETA: {eta} {extra_info}")

    @staticmethod
    def _format_bytes(bytes_val: float) -> str:
        """Format bytes with appropriate units"""
        for unit in ['B', 'KB', 'MB', 'GB', 'TB']:
            if bytes_val < 1024:
                return f"{bytes_val:.1f}{unit}"
            bytes_val /= 1024
        return f"{bytes_val:.1f}PB"

    @staticmethod
    def _format_duration(seconds: float) -> str:
        """Format duration in human readable format"""
        if seconds < 60:
            return f"{int(seconds)}s"
        elif seconds < 3600:
            return f"{int(seconds // 60)}m {int(seconds % 60)}s"
        else:
            hours = int(seconds // 3600)
            minutes = int((seconds % 3600) // 60)
            return f"{hours}h {minutes}m"

class ModernUI:
    """Advanced terminal UI with modern design elements"""
    
    @staticmethod
    def print_banner():
        """Display enhanced banner with version info"""
        banner_text = """
‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïÆ
‚îÇ  ‚ñà‚ñà‚ïó   ‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚îÇ
‚îÇ  ‚ïö‚ñà‚ñà‚ïó ‚ñà‚ñà‚ïî‚ïù‚ïö‚ïê‚ïê‚ñà‚ñà‚ïî‚ïê‚ïê‚ïù‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚îÇ
‚îÇ   ‚ïö‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù    ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚îÇ
‚îÇ    ‚ïö‚ñà‚ñà‚ïî‚ïù     ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚îÇ
‚îÇ     ‚ñà‚ñà‚ïë      ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ïö‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë‚îÇ
‚îÇ     ‚ïö‚ïê‚ïù      ‚ïö‚ïê‚ïù   ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù  ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù ‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïù‚îÇ
‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ"""
        
        print(Colors.gradient_text(banner_text, (64, 224, 255), (255, 100, 255)))
        print(f"\n{Colors.PRIMARY}{Colors.BOLD}YtDorn v0.1.2{Colors.RESET} {Colors.MUTED}by 0xb0rn3{Colors.RESET}")
        print(f"{Colors.INFO}Super Powerful YouTube Downloader{Colors.RESET}")
        print(f"{Colors.MUTED}https://github.com/0xb0rn3{Colors.RESET}")
        print(Colors.gradient_text('‚ïê' * 50, (64, 224, 255), (255, 100, 255)))

    @staticmethod
    def create_interactive_menu(title: str, options: List[Tuple[str, str, str]], 
                               show_shortcuts: bool = True) -> str:
        """Create modern interactive menu with shortcuts and descriptions"""
        print(f"\n{Colors.PRIMARY}{Colors.BOLD}‚îå‚îÄ {title} ‚îÄ‚îê{Colors.RESET}")
        
        for i, (key, title_text, description) in enumerate(options, 1):
            icon = key if len(key) == 1 else str(i)
            shortcut = f"[{icon}]" if show_shortcuts else f"[{i}]"
            print(f"{Colors.INFO}{shortcut:<4}{Colors.RESET} {title_text}")
            if description:
                print(f"     {Colors.MUTED}{description}{Colors.RESET}")
        
        print(f"{Colors.PRIMARY}‚îî{'‚îÄ' * (len(title) + 4)}‚îò{Colors.RESET}")
        
        while True:
            prompt = f"\n{Colors.PRIMARY}‚ùØ{Colors.RESET} Select option: "
            choice = input(prompt).strip().lower()
            
            # Check for direct key match or number
            for i, (key, _, _) in enumerate(options, 1):
                if choice == key.lower() or choice == str(i):
                    return str(i)
            
            print(f"{Colors.ERROR}Invalid selection. Please try again.{Colors.RESET}")

    @staticmethod
    def get_user_input(prompt: str, default: str = None, validator=None) -> str:
        """Enhanced input with validation and defaults"""
        display_default = f" ({default})" if default else ""
        full_prompt = f"{Colors.PRIMARY}‚ùØ{Colors.RESET} {prompt}{Colors.MUTED}{display_default}{Colors.RESET}: "
        
        while True:
            value = input(full_prompt).strip()
            if not value and default:
                return default
            if not value:
                print(f"{Colors.ERROR}This field is required.{Colors.RESET}")
                continue
            if validator and not validator(value):
                print(f"{Colors.ERROR}Invalid input. Please try again.{Colors.RESET}")
                continue
            return value

    @staticmethod
    def show_info_panel(title: str, items: Dict[str, str]):
        """Display information in a modern panel format"""
        max_key_length = max(len(key) for key in items.keys()) if items else 0
        
        print(f"\n{Colors.INFO}‚îå‚îÄ {title} {'‚îÄ' * (max_key_length + 20)}")
        for key, value in items.items():
            print(f"{Colors.INFO}‚îÇ{Colors.RESET} {key:<{max_key_length}} : {Colors.PRIMARY}{value}{Colors.RESET}")
        print(f"{Colors.INFO}‚îî{'‚îÄ' * (max_key_length + len(title) + 25)}{Colors.RESET}")

class DependencyManager:
    """Advanced dependency management with better error handling"""
    
    @staticmethod
    def check_system_dependencies() -> Dict[str, bool]:
        """Comprehensive dependency check"""
        deps = {}
        
        # Check yt-dlp
        deps['yt-dlp'] = shutil.which('yt-dlp') is not None
        if not deps['yt-dlp']:
            try:
                import yt-dlp 
                deps['yt-dlp'] = True
            except ImportError:
                pass
        
        # Check ffmpeg
        deps['ffmpeg'] = shutil.which('ffmpeg') is not None
        
        # Check Python version
        deps['python'] = sys.version_info >= (3, 7)
        
        return deps

    @staticmethod
    def install_missing_dependencies(spinner: ModernSpinner):
        """Install missing dependencies with progress feedback"""
        deps = DependencyManager.check_system_dependencies()
        
        if all(deps.values()):
            return True
        
        spinner.start("Checking system dependencies...")
        time.sleep(1)
        spinner.stop()
        
        if not deps['python']:
            print(f"{Colors.ERROR}Python 3.7+ is required. Please upgrade Python.{Colors.RESET}")
            return False
        
        if not deps['yt-dlp']:
            spinner.start("Installing yt-dlp...")
            try:
                subprocess.check_call([
                    sys.executable, "-m", "pip", "install", "yt-dlp", "--upgrade"
                ], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
                spinner.stop(f"{Colors.SUCCESS}‚úì yt-dlp installed successfully{Colors.RESET}")
            except subprocess.CalledProcessError:
                spinner.stop(f"{Colors.ERROR}‚úó Failed to install yt-dlp{Colors.RESET}")
                return False
        
        if not deps['ffmpeg']:
            spinner.start("Setting up ffmpeg...")
            if DependencyManager._install_ffmpeg():
                spinner.stop(f"{Colors.SUCCESS}‚úì ffmpeg configured successfully{Colors.RESET}")
            else:
                spinner.stop(f"{Colors.WARNING}‚ö† ffmpeg not found - some features may be limited{Colors.RESET}")
        
        return True

    @staticmethod
    def _install_ffmpeg() -> bool:
        """Attempt to install ffmpeg based on the system"""
        system = platform.system().lower()
        
        try:
            if system == "windows":
                # Try winget first, then chocolatey
                for cmd in [['winget', 'install', 'ffmpeg'], ['choco', 'install', 'ffmpeg', '-y']]:
                    if shutil.which(cmd[0]):
                        subprocess.check_call(cmd, capture_output=True)
                        return True
            elif system == "darwin":
                if shutil.which('brew'):
                    subprocess.check_call(['brew', 'install', 'ffmpeg'], capture_output=True)
                    return True
            elif system == "linux":
                # Try multiple package managers
                pkg_managers = [
                    (['apt', 'update'], ['apt', 'install', '-y', 'ffmpeg']),
                    (['dnf', 'install', '-y', 'ffmpeg'],),
                    (['pacman', '-Sy', '--noconfirm', 'ffmpeg'],),
                    (['zypper', 'install', '-y', 'ffmpeg'],)
                ]
                
                for commands in pkg_managers:
                    if shutil.which(commands[0][0]):
                        for cmd in commands:
                            subprocess.check_call(cmd, capture_output=True)
                        return True
        except subprocess.CalledProcessError:
            pass
        
        return False

class SuperDownloader:
    """Advanced downloader with comprehensive YouTube support"""
    
    def __init__(self):
        self.progress_bars = {}
        self.download_stats = {}
        self.concurrent_downloads = 3
        
    def download_hook(self, d: Dict[str, Any]):
        """Enhanced progress hook with detailed tracking"""
        filename = d.get('filename', 'Unknown')
        base_filename = os.path.basename(filename)
        
        if d['status'] == 'downloading':
            if base_filename not in self.progress_bars:
                total_bytes = d.get('total_bytes', 0) or d.get('total_bytes_estimate', 0)
                self.progress_bars[base_filename] = AdvancedProgressBar(
                    total_bytes, 
                    base_filename[:25]
                )
                self.download_stats[base_filename] = {'start_time': time.time()}
            
            downloaded = d.get('downloaded_bytes', 0)
            speed = d.get('speed', 0)
            
            extra_info = ""
            if speed:
                extra_info = f"({AdvancedProgressBar._format_bytes(speed)}/s)"
            
            progress_line = self.progress_bars[base_filename].update(downloaded, extra_info)
            sys.stdout.write(progress_line)
            sys.stdout.flush()
            
        elif d['status'] == 'finished':
            if base_filename in self.progress_bars:
                duration = time.time() - self.download_stats[base_filename]['start_time']
                sys.stdout.write('\r\033[K')
                print(f"{Colors.SUCCESS}‚úì {base_filename} completed in "
                      f"{AdvancedProgressBar._format_duration(duration)}{Colors.RESET}")
                del self.progress_bars[base_filename]
                del self.download_stats[base_filename]

    def get_video_info(self, url: str) -> Dict[str, Any]:
        """Extract comprehensive video information"""
        from yt_dlp import YoutubeDL
        
        ydl_opts = {
            'quiet': True,
            'no_warnings': True,
            'extract_flat': False,
        }
        
        with YoutubeDL(ydl_opts) as ydl:
            try:
                info = ydl.extract_info(url, download=False)
                return self._process_video_info(info)
            except Exception as e:
                raise Exception(f"Could not extract video info: {str(e)}")

    def _process_video_info(self, info: Dict[str, Any]) -> Dict[str, Any]:
        """Process and clean video information"""
        processed = {
            'title': info.get('title', 'Unknown'),
            'uploader': info.get('uploader', 'Unknown'),
            'duration': info.get('duration', 0),
            'view_count': info.get('view_count', 0),
            'upload_date': info.get('upload_date', ''),
            'description': info.get('description', '')[:200] + '...' if info.get('description') else '',
            'formats': len(info.get('formats', [])),
            'is_live': info.get('is_live', False),
            'is_playlist': 'entries' in info,
        }
        
        if processed['is_playlist']:
            processed['playlist_count'] = len(info.get('entries', []))
            processed['playlist_title'] = info.get('title', 'Unknown Playlist')
        
        return processed

    def download_with_options(self, url: str, options: Dict[str, Any]):
        """Download with comprehensive options"""
        from yt_dlp import YoutubeDL
        
        # Build yt-dlp options
        ydl_opts = {
            'outtmpl': options.get('output_template', '%(title)s.%(ext)s'),
            'format': options.get('format', 'best'),
            'writesubtitles': options.get('subtitles', False),
            'writeautomaticsub': options.get('auto_subtitles', False),
            'writethumbnail': options.get('thumbnail', False),
            'writedescription': options.get('description', False),
            'writeinfojson': options.get('metadata', False),
            'ignoreerrors': True,
            'no_warnings': True,
            'progress_hooks': [self.download_hook],
        }
        
        # Add post-processors based on options
        postprocessors = []
        
        if options.get('extract_audio'):
            postprocessors.append({
                'key': 'FFmpegExtractAudio',
                'preferredcodec': options.get('audio_format', 'mp3'),
                'preferredquality': options.get('audio_quality', '192'),
            })
        
        if options.get('embed_subs'):
            postprocessors.append({
                'key': 'FFmpegEmbedSubtitle',
            })
        
        if postprocessors:
            ydl_opts['postprocessors'] = postprocessors
        
        # Handle playlist options
        if options.get('playlist_items'):
            ydl_opts['playlist_items'] = options['playlist_items']
        
        try:
            with YoutubeDL(ydl_opts) as ydl:
                ydl.download([url])
            return True
        except Exception as e:
            print(f"{Colors.ERROR}Download failed: {str(e)}{Colors.RESET}")
            return False

    @staticmethod
    def get_format_options() -> List[Tuple[str, str, str]]:
        """Get available format options with descriptions"""
        return [
            ('best', 'üé¨ Best Quality', 'Highest available quality (video + audio)'),
            ('1080p', 'üì∫ 1080p HD', 'Full HD quality (1920x1080)'),
            ('720p', 'üìπ 720p HD', 'HD quality (1280x720)'),
            ('480p', 'üì± 480p SD', 'Standard definition (854x480)'),
            ('audio', 'üéµ Audio Only', 'Extract audio only (best quality)'),
            ('mp3', 'üé∂ MP3 Audio', 'Convert to MP3 format'),
            ('custom', '‚öôÔ∏è Custom', 'Specify custom format'),
        ]

def create_advanced_options_menu() -> Dict[str, Any]:
    """Create comprehensive options selection"""
    ui = ModernUI()
    options = {}
    
    # Output directory
    options['output_dir'] = ui.get_user_input(
        "Output directory", 
        default="downloads",
        validator=lambda x: True  # Allow any directory name
    )
    
    # Format selection
    format_options = SuperDownloader.get_format_options()
    format_choice = ui.create_interactive_menu("Format Selection", format_options)
    format_map = {
        '1': 'best[ext=mp4]/best',
        '2': 'best[height<=1080][ext=mp4]/best[height<=1080]',
        '3': 'best[height<=720][ext=mp4]/best[height<=720]',
        '4': 'best[height<=480][ext=mp4]/best[height<=480]',
        '5': 'bestaudio',
        '6': 'bestaudio[ext=m4a]/bestaudio',
        '7': ui.get_user_input("Enter custom format string", default="best")
    }
    options['format'] = format_map.get(format_choice, 'best')
    
    # Additional options
    extra_options = [
        ('y', 'üì• Download subtitles', ''),
        ('n', '‚ùå Skip subtitles', ''),
    ]
    sub_choice = ui.create_interactive_menu("Subtitle Options", extra_options)
    options['subtitles'] = sub_choice == '1'
    
    extra_features = [
        ('y', 'üñºÔ∏è Download thumbnail', ''),
        ('n', '‚ùå Skip thumbnail', ''),
    ]
    thumb_choice = ui.create_interactive_menu("Thumbnail Options", extra_features)
    options['thumbnail'] = thumb_choice == '1'
    
    # Set output template
    safe_title = "%(title).100s"
    if options['subtitles'] or options['thumbnail']:
        template = f"{options['output_dir']}/{safe_title}.%(ext)s"
    else:
        template = f"{options['output_dir']}/{safe_title}.%(ext)s"
    options['output_template'] = template
    
    return options

def validate_url(url: str) -> bool:
    """Validate YouTube URL"""
    youtube_domains = ['youtube.com', 'youtu.be', 'm.youtube.com', 'music.youtube.com']
    try:
        parsed = urlparse(url)
        return any(domain in parsed.netloc for domain in youtube_domains)
    except:
        return False

def main():
    """Enhanced main function with comprehensive features"""
    # Setup
    ui = ModernUI()
    spinner = ModernSpinner()
    downloader = SuperDownloader()
    
    # Signal handler for graceful exit
    def signal_handler(signum, frame):
        print(f"\n\n{Colors.WARNING}üõë Download interrupted. Exiting gracefully...{Colors.RESET}\n")
        sys.exit(0)
    
    signal.signal(signal.SIGINT, signal_handler)
    
    # Display banner
    ui.print_banner()
    
    # Check dependencies
    if not DependencyManager.install_missing_dependencies(spinner):
        print(f"{Colors.ERROR}Failed to install required dependencies. Exiting.{Colors.RESET}")
        sys.exit(1)
    
    print(f"\n{Colors.SUCCESS}üöÄ System ready! All dependencies satisfied.{Colors.RESET}")
    
    while True:
        try:
            print(f"\n{Colors.gradient_text('‚ïê' * 60, (64, 224, 255), (255, 100, 255))}")
            
            # Main menu
            main_options = [
                ('s', 'üé• Single Video', 'Download individual video'),
                ('p', 'üìã Playlist/Channel', 'Download playlist or entire channel'),
                ('i', 'üìä Video Info', 'Get detailed video information'),
                ('q', 'üö™ Quit', 'Exit the application'),
            ]
            
            choice = ui.create_interactive_menu("Main Menu", main_options)
            
            if choice == '4':  # Quit
                print(f"\n{Colors.SUCCESS}üëã Thank you for using YtDorn! Goodbye!{Colors.RESET}\n")
                break
            
            # Get URL
            url = ui.get_user_input("YouTube URL", validator=validate_url)
            
            if choice == '3':  # Video info
                spinner.start("Extracting video information...")
                try:
                    info = downloader.get_video_info(url)
                    spinner.stop()
                    
                    # Display info
                    info_items = {
                        'Title': info['title'],
                        'Uploader': info['uploader'],
                        'Duration': AdvancedProgressBar._format_duration(info['duration']),
                        'Views': f"{info['view_count']:,}" if info['view_count'] else 'Unknown',
                        'Upload Date': info['upload_date'],
                        'Available Formats': str(info['formats']),
                        'Is Live': 'Yes' if info['is_live'] else 'No',
                    }
                    
                    if info['is_playlist']:
                        info_items['Playlist Title'] = info['playlist_title']
                        info_items['Video Count'] = str(info['playlist_count'])
                    
                    ui.show_info_panel("Video Information", info_items)
                    
                except Exception as e:
                    spinner.stop(f"{Colors.ERROR}Failed to get video info: {str(e)}{Colors.RESET}")
                
                continue
            
            # Get download options
            spinner.start("Analyzing video...")
            try:
                info = downloader.get_video_info(url)
                spinner.stop()
                
                # Show basic info
                basic_info = {
                    'Title': info['title'][:50] + '...' if len(info['title']) > 50 else info['title'],
                    'Type': 'Playlist' if info['is_playlist'] else 'Single Video',
                    'Duration/Count': (f"{info['playlist_count']} videos" if info['is_playlist'] 
                                     else AdvancedProgressBar._format_duration(info['duration'])),
                }
                ui.show_info_panel("Download Preview", basic_info)
                
            except Exception as e:
                spinner.stop(f"{Colors.ERROR}Error: {str(e)}{Colors.RESET}")
                continue
            
            # Get advanced options
            options = create_advanced_options_menu()
            
            # Confirm download
            confirm_options = [
                ('y', '‚úÖ Start Download', 'Begin downloading with selected options'),
                ('n', '‚ùå Cancel', 'Return to main menu'),
                ('m', '‚öôÔ∏è Modify Options', 'Change download settings'),
            ]
            
            confirm_choice = ui.create_interactive_menu("Confirm Download", confirm_options)
            
            if confirm_choice == '2':  # Cancel
                continue
            elif confirm_choice == '3':  # Modify options
                options = create_advanced_options_menu()
                confirm_choice = '1'  # Proceed with download
            
            if confirm_choice == '1':  # Start download
                print(f"\n{Colors.PRIMARY}üöÄ Starting download...{Colors.RESET}")
                
                # Create output directory
                os.makedirs(options['output_dir'], exist_ok=True)
                
                # Start download
                success = downloader.download_with_options(url, options)
                
                if success:
                    print(f"\n{Colors.SUCCESS}‚ú® Download completed successfully!{Colors.RESET}")
                    print(f"{Colors.INFO}üìÅ Files saved to: {os.path.abspath(options['output_dir'])}{Colors.RESET}")
                else:
                    print(f"\n{Colors.ERROR}‚ùå Download failed. Please check the URL and try again.{Colors.RESET}")
        
        except KeyboardInterrupt:
            print(f"\n\n{Colors.WARNING}üõë Operation cancelled by user.{Colors.RESET}")
            continue
        except Exception as e:
            print(f"\n{Colors.ERROR}‚ùå Unexpected error: {str(e)}{Colors.RESET}")
            continue
        
        # Ask if user wants to continue
        continue_options = [
            ('y', 'üîÑ Download Another', 'Start a new download'),
            ('n', 'üö™ Exit', 'Quit the application'),
        ]
        
        continue_choice = ui.create_interactive_menu("Continue?", continue_options)
        if continue_choice == '2':
            print(f"\n{Colors.SUCCESS}üëã Thank you for using YtDorn! Goodbye!{Colors.RESET}\n")
            break

class BatchDownloader:
    """Handle batch downloads from file or multiple URLs"""
    
    @staticmethod
    def download_from_file(file_path: str, options: Dict[str, Any]) -> bool:
        """Download multiple URLs from a text file"""
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                urls = [line.strip() for line in f if line.strip() and validate_url(line.strip())]
            
            if not urls:
                print(f"{Colors.ERROR}No valid URLs found in file.{Colors.RESET}")
                return False
            
            print(f"{Colors.INFO}Found {len(urls)} valid URLs to download.{Colors.RESET}")
            
            downloader = SuperDownloader()
            successful = 0
            
            for i, url in enumerate(urls, 1):
                print(f"\n{Colors.PRIMARY}üì• Downloading {i}/{len(urls)}{Colors.RESET}")
                if downloader.download_with_options(url, options):
                    successful += 1
                else:
                    print(f"{Colors.WARNING}‚ö†Ô∏è Skipping failed URL: {url}{Colors.RESET}")
            
            print(f"\n{Colors.SUCCESS}‚úÖ Batch download completed: {successful}/{len(urls)} successful{Colors.RESET}")
            return True
            
        except FileNotFoundError:
            print(f"{Colors.ERROR}File not found: {file_path}{Colors.RESET}")
            return False
        except Exception as e:
            print(f"{Colors.ERROR}Error processing file: {str(e)}{Colors.RESET}")
            return False

class ConfigManager:
    """Manage user configurations and presets"""
    
    CONFIG_FILE = os.path.expanduser("~/.ytdorn_config.json")
    
    @staticmethod
    def load_config() -> Dict[str, Any]:
        """Load user configuration"""
        try:
            if os.path.exists(ConfigManager.CONFIG_FILE):
                with open(ConfigManager.CONFIG_FILE, 'r') as f:
                    return json.load(f)
        except Exception:
            pass
        return ConfigManager._get_default_config()
    
    @staticmethod
    def save_config(config: Dict[str, Any]) -> bool:
        """Save user configuration"""
        try:
            with open(ConfigManager.CONFIG_FILE, 'w') as f:
                json.dump(config, f, indent=2)
            return True
        except Exception:
            return False
    
    @staticmethod
    def _get_default_config() -> Dict[str, Any]:
        """Get default configuration"""
        return {
            'default_output_dir': 'downloads',
            'default_format': 'best',
            'auto_subtitles': False,
            'download_thumbnails': False,
            'concurrent_downloads': 3,
            'presets': {
                'high_quality': {
                    'format': 'best[ext=mp4]/best',
                    'subtitles': True,
                    'thumbnail': True,
                },
                'audio_only': {
                    'format': 'bestaudio',
                    'extract_audio': True,
                    'audio_format': 'mp3',
                },
                'mobile': {
                    'format': 'best[height<=720]',
                    'subtitles': False,
                    'thumbnail': False,
                }
            }
        }

def setup_argument_parser() -> argparse.ArgumentParser:
    """Setup command line argument parser"""
    parser = argparse.ArgumentParser(
        description='YtDorn v0.1.2 - Super Powerful YouTube Downloader',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  %(prog)s                                    # Interactive mode
  %(prog)s -u "URL" -f best                   # Quick download
  %(prog)s -u "URL" -f audio --extract-audio  # Audio only
  %(prog)s --batch urls.txt                   # Batch download
  %(prog)s --info "URL"                       # Get video info only
        """
    )
    
    parser.add_argument('-u', '--url', help='YouTube URL to download')
    parser.add_argument('-f', '--format', default='best', help='Video format/quality')
    parser.add_argument('-o', '--output', default='downloads', help='Output directory')
    parser.add_argument('--extract-audio', action='store_true', help='Extract audio only')
    parser.add_argument('--audio-format', default='mp3', help='Audio format (mp3, m4a, wav)')
    parser.add_argument('--subtitles', action='store_true', help='Download subtitles')
    parser.add_argument('--thumbnail', action='store_true', help='Download thumbnail')
    parser.add_argument('--batch', help='Batch download from file')
    parser.add_argument('--info', help='Get video information only')
    parser.add_argument('--preset', help='Use configuration preset')
    parser.add_argument('--list-presets', action='store_true', help='List available presets')
    parser.add_argument('--quiet', '-q', action='store_true', help='Quiet mode')
    parser.add_argument('--version', action='version', version='YtDorn v0.1.2 by 0xb0rn3')
    
    return parser

def run_cli_mode(args):
    """Run in command line mode with arguments"""
    if args.list_presets:
        config = ConfigManager.load_config()
        print("Available presets:")
        for name, settings in config['presets'].items():
            print(f"  {name}: {settings}")
        return
    
    if args.info:
        downloader = SuperDownloader()
        try:
            info = downloader.get_video_info(args.info)
            print(json.dumps(info, indent=2))
        except Exception as e:
            print(f"Error: {str(e)}", file=sys.stderr)
            sys.exit(1)
        return
    
    # Build options from command line arguments
    options = {
        'output_dir': args.output,
        'format': args.format,
        'subtitles': args.subtitles,
        'thumbnail': args.thumbnail,
        'extract_audio': args.extract_audio,
        'audio_format': args.audio_format,
    }
    
    # Apply preset if specified
    if args.preset:
        config = ConfigManager.load_config()
        if args.preset in config['presets']:
            preset = config['presets'][args.preset]
            options.update(preset)
        else:
            print(f"Error: Preset '{args.preset}' not found", file=sys.stderr)
            sys.exit(1)
    
    # Set output template
    options['output_template'] = f"{options['output_dir']}/%(title).100s.%(ext)s"
    
    downloader = SuperDownloader()
    
    if args.batch:
        # Batch download mode
        batch_downloader = BatchDownloader()
        success = batch_downloader.download_from_file(args.batch, options)
        sys.exit(0 if success else 1)
    
    elif args.url:
        # Single URL download
        if not validate_url(args.url):
            print("Error: Invalid YouTube URL", file=sys.stderr)
            sys.exit(1)
        
        os.makedirs(options['output_dir'], exist_ok=True)
        success = downloader.download_with_options(args.url, options)
        sys.exit(0 if success else 1)
    
    else:
        print("Error: No URL or batch file specified", file=sys.stderr)
        sys.exit(1)

if __name__ == "__main__":
    try:
        # Check if running in CLI mode (with arguments)
        parser = setup_argument_parser()
        args = parser.parse_args()
        # Check if meaningful CLI arguments were provided
        # These are the arguments that actually indicate the user wants CLI mode
        meaningful_args = [
            args.url,           # User provided a URL to download
            args.batch,         # User provided a batch file
            args.info,          # User wants video info only
            args.list_presets   # User wants to see available presets
        ]
        
        # Only run CLI mode if user provided meaningful arguments
        if any(meaningful_args):
            run_cli_mode(args)
        else:
            # No meaningful arguments provided, so run interactive mode
            main()
            
    except KeyboardInterrupt:
        print(f"\n{Colors.WARNING}üõë Application interrupted by user. Goodbye!{Colors.RESET}")
        sys.exit(0)
    except Exception as e:
        print(f"{Colors.ERROR}Fatal error: {str(e)}{Colors.RESET}")
        sys.exit(1)
